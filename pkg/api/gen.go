// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

// Defines values for BidAuthorType.
const (
	Organization BidAuthorType = "Organization"
	User         BidAuthorType = "User"
)

// Defines values for BidDecision.
const (
	Approved BidDecision = "Approved"
	Rejected BidDecision = "Rejected"
)

// Defines values for BidStatus.
const (
	BidStatusCanceled  BidStatus = "Canceled"
	BidStatusCreated   BidStatus = "Created"
	BidStatusPublished BidStatus = "Published"
)

// Defines values for TenderServiceType.
const (
	Construction TenderServiceType = "Construction"
	Delivery     TenderServiceType = "Delivery"
	Manufacture  TenderServiceType = "Manufacture"
)

// Defines values for TenderStatus.
const (
	TenderStatusClosed    TenderStatus = "Closed"
	TenderStatusCreated   TenderStatus = "Created"
	TenderStatusPublished TenderStatus = "Published"
)

// Bid Информация о предложении
type Bid struct {
	// AuthorId Уникальный идентификатор автора предложения, присвоенный сервером.
	AuthorId BidAuthorId `json:"authorId"`

	// AuthorType Тип автора
	AuthorType BidAuthorType `json:"authorType"`

	// CreatedAt Серверная дата и время в момент, когда пользователь отправил предложение на создание.
	// Передается в формате RFC3339.
	CreatedAt string `json:"createdAt"`

	// Description Описание предложения
	Description BidDescription `json:"description"`

	// Id Уникальный идентификатор предложения, присвоенный сервером.
	Id BidId `json:"id"`

	// Name Полное название предложения
	Name BidName `json:"name"`

	// Status Статус предложения
	Status BidStatus `json:"status"`

	// TenderId Уникальный идентификатор тендера, присвоенный сервером.
	TenderId TenderId `json:"tenderId"`

	// Version Номер версии посел правок
	Version BidVersion `json:"version"`
}

// BidAuthorId Уникальный идентификатор автора предложения, присвоенный сервером.
type BidAuthorId = string

// BidAuthorType Тип автора
type BidAuthorType string

// BidDecision Решение по предложению
type BidDecision string

// BidDescription Описание предложения
type BidDescription = string

// BidFeedback Отзыв на предложение
type BidFeedback = string

// BidId Уникальный идентификатор предложения, присвоенный сервером.
type BidId = string

// BidName Полное название предложения
type BidName = string

// BidReview Отзыв о предложении
type BidReview struct {
	// CreatedAt Серверная дата и время в момент, когда пользователь отправил отзыв на предложение.
	// Передается в формате RFC3339.
	CreatedAt string `json:"createdAt"`

	// Description Описание предложения
	Description BidReviewDescription `json:"description"`

	// Id Уникальный идентификатор отзыва, присвоенный сервером.
	Id BidReviewId `json:"id"`
}

// BidReviewDescription Описание предложения
type BidReviewDescription = string

// BidReviewId Уникальный идентификатор отзыва, присвоенный сервером.
type BidReviewId = string

// BidStatus Статус предложения
type BidStatus string

// BidVersion Номер версии посел правок
type BidVersion = int32

// ErrorResponse Используется для возвращения ошибки пользователю
type ErrorResponse struct {
	// Reason Описание ошибки в свободной форме
	Reason string `json:"reason"`
}

// OrganizationId Уникальный идентификатор организации, присвоенный сервером.
type OrganizationId = string

// Tender Информация о тендере
type Tender struct {
	// CreatedAt Серверная дата и время в момент, когда пользователь отправил тендер на создание.
	// Передается в формате RFC3339.
	CreatedAt string `json:"createdAt"`

	// Description Описание тендера
	Description TenderDescription `json:"description"`

	// Id Уникальный идентификатор тендера, присвоенный сервером.
	Id TenderId `json:"id"`

	// Name Полное название тендера
	Name TenderName `json:"name"`

	// OrganizationId Уникальный идентификатор организации, присвоенный сервером.
	OrganizationId OrganizationId `json:"organizationId"`

	// ServiceType Вид услуги, к которой относиться тендер
	ServiceType TenderServiceType `json:"serviceType"`

	// Status Статус тендер
	Status TenderStatus `json:"status"`

	// Version Номер версии посел правок
	Version TenderVersion `json:"version"`
}

// TenderDescription Описание тендера
type TenderDescription = string

// TenderId Уникальный идентификатор тендера, присвоенный сервером.
type TenderId = string

// TenderName Полное название тендера
type TenderName = string

// TenderServiceType Вид услуги, к которой относиться тендер
type TenderServiceType string

// TenderStatus Статус тендер
type TenderStatus string

// TenderVersion Номер версии посел правок
type TenderVersion = int32

// Username Уникальный slug пользователя.
type Username = string

// PaginationLimit defines model for paginationLimit.
type PaginationLimit = int32

// PaginationOffset defines model for paginationOffset.
type PaginationOffset = int32

// GetUserBidsParams defines parameters for GetUserBids.
type GetUserBidsParams struct {
	// Limit Максимальное число возвращаемых объектов. Используется для запросов с пагинацией.
	//
	// Сервер должен возвращать максимальное допустимое число объектов.
	Limit *PaginationLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Какое количество объектов должно быть пропущено с начала. Используется для запросов с пагинацией.
	Offset   *PaginationOffset `form:"offset,omitempty" json:"offset,omitempty"`
	Username *Username         `form:"username,omitempty" json:"username,omitempty"`
}

// CreateBidJSONBody defines parameters for CreateBid.
type CreateBidJSONBody struct {
	// CreatorUsername Уникальный slug пользователя.
	CreatorUsername Username `json:"creatorUsername"`

	// Description Описание предложения
	Description BidDescription `json:"description"`

	// Name Полное название предложения
	Name BidName `json:"name"`

	// OrganizationId Уникальный идентификатор организации, присвоенный сервером.
	OrganizationId OrganizationId `json:"organizationId"`

	// Status Статус предложения
	Status BidStatus `json:"status"`

	// TenderId Уникальный идентификатор тендера, присвоенный сервером.
	TenderId TenderId `json:"tenderId"`
}

// EditBidJSONBody defines parameters for EditBid.
type EditBidJSONBody struct {
	// Description Описание предложения
	Description *BidDescription `json:"description,omitempty"`

	// Name Полное название предложения
	Name *BidName `json:"name,omitempty"`
}

// EditBidParams defines parameters for EditBid.
type EditBidParams struct {
	Username Username `form:"username" json:"username"`
}

// SubmitBidFeedbackParams defines parameters for SubmitBidFeedback.
type SubmitBidFeedbackParams struct {
	BidFeedback BidFeedback `form:"bidFeedback" json:"bidFeedback"`
	Username    Username    `form:"username" json:"username"`
}

// RollbackBidParams defines parameters for RollbackBid.
type RollbackBidParams struct {
	Username Username `form:"username" json:"username"`
}

// GetBidStatusParams defines parameters for GetBidStatus.
type GetBidStatusParams struct {
	Username Username `form:"username" json:"username"`
}

// UpdateBidStatusParams defines parameters for UpdateBidStatus.
type UpdateBidStatusParams struct {
	Status   BidStatus `form:"status" json:"status"`
	Username Username  `form:"username" json:"username"`
}

// SubmitBidDecisionParams defines parameters for SubmitBidDecision.
type SubmitBidDecisionParams struct {
	Decision BidDecision `form:"decision" json:"decision"`
	Username Username    `form:"username" json:"username"`
}

// GetBidsForTenderParams defines parameters for GetBidsForTender.
type GetBidsForTenderParams struct {
	Username Username `form:"username" json:"username"`

	// Limit Максимальное число возвращаемых объектов. Используется для запросов с пагинацией.
	//
	// Сервер должен возвращать максимальное допустимое число объектов.
	Limit *PaginationLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Какое количество объектов должно быть пропущено с начала. Используется для запросов с пагинацией.
	Offset *PaginationOffset `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetBidReviewsParams defines parameters for GetBidReviews.
type GetBidReviewsParams struct {
	// AuthorUsername Имя пользователя автора предложений, отзывы на которые нужно просмотреть.
	AuthorUsername Username `form:"authorUsername" json:"authorUsername"`

	// RequesterUsername Имя пользователя, который запрашивает отзывы.
	RequesterUsername Username `form:"requesterUsername" json:"requesterUsername"`

	// Limit Максимальное число возвращаемых объектов. Используется для запросов с пагинацией.
	//
	// Сервер должен возвращать максимальное допустимое число объектов.
	Limit *PaginationLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Какое количество объектов должно быть пропущено с начала. Используется для запросов с пагинацией.
	Offset *PaginationOffset `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetTendersParams defines parameters for GetTenders.
type GetTendersParams struct {
	// Limit Максимальное число возвращаемых объектов. Используется для запросов с пагинацией.
	//
	// Сервер должен возвращать максимальное допустимое число объектов.
	Limit *PaginationLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Какое количество объектов должно быть пропущено с начала. Используется для запросов с пагинацией.
	Offset *PaginationOffset `form:"offset,omitempty" json:"offset,omitempty"`

	// ServiceType Возвращенные тендеры должны соответствовать указанным видам услуг.
	//
	// Если список пустой, фильтры не применяются.
	ServiceType *[]TenderServiceType `form:"service_type,omitempty" json:"service_type,omitempty"`
}

// GetUserTendersParams defines parameters for GetUserTenders.
type GetUserTendersParams struct {
	// Limit Максимальное число возвращаемых объектов. Используется для запросов с пагинацией.
	//
	// Сервер должен возвращать максимальное допустимое число объектов.
	Limit *PaginationLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Какое количество объектов должно быть пропущено с начала. Используется для запросов с пагинацией.
	Offset   *PaginationOffset `form:"offset,omitempty" json:"offset,omitempty"`
	Username *Username         `form:"username,omitempty" json:"username,omitempty"`
}

// CreateTenderJSONBody defines parameters for CreateTender.
type CreateTenderJSONBody struct {
	// CreatorUsername Уникальный slug пользователя.
	CreatorUsername Username `json:"creatorUsername"`

	// Description Описание тендера
	Description TenderDescription `json:"description"`

	// Name Полное название тендера
	Name TenderName `json:"name"`

	// OrganizationId Уникальный идентификатор организации, присвоенный сервером.
	OrganizationId OrganizationId `json:"organizationId"`

	// ServiceType Вид услуги, к которой относиться тендер
	ServiceType TenderServiceType `json:"serviceType"`

	// Status Статус тендер
	Status TenderStatus `json:"status"`
}

// EditTenderJSONBody defines parameters for EditTender.
type EditTenderJSONBody struct {
	// Description Описание тендера
	Description *TenderDescription `json:"description,omitempty"`

	// Name Полное название тендера
	Name *TenderName `json:"name,omitempty"`

	// ServiceType Вид услуги, к которой относиться тендер
	ServiceType *TenderServiceType `json:"serviceType,omitempty"`
}

// EditTenderParams defines parameters for EditTender.
type EditTenderParams struct {
	Username Username `form:"username" json:"username"`
}

// RollbackTenderParams defines parameters for RollbackTender.
type RollbackTenderParams struct {
	Username Username `form:"username" json:"username"`
}

// GetTenderStatusParams defines parameters for GetTenderStatus.
type GetTenderStatusParams struct {
	Username *Username `form:"username,omitempty" json:"username,omitempty"`
}

// UpdateTenderStatusParams defines parameters for UpdateTenderStatus.
type UpdateTenderStatusParams struct {
	Status   TenderStatus `form:"status" json:"status"`
	Username Username     `form:"username" json:"username"`
}

// CreateBidJSONRequestBody defines body for CreateBid for application/json ContentType.
type CreateBidJSONRequestBody CreateBidJSONBody

// EditBidJSONRequestBody defines body for EditBid for application/json ContentType.
type EditBidJSONRequestBody EditBidJSONBody

// CreateTenderJSONRequestBody defines body for CreateTender for application/json ContentType.
type CreateTenderJSONRequestBody CreateTenderJSONBody

// EditTenderJSONRequestBody defines body for EditTender for application/json ContentType.
type EditTenderJSONRequestBody EditTenderJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Получение списка ваших предложений
	// (GET /bids/my)
	GetUserBids(ctx echo.Context, params GetUserBidsParams) error
	// Создание нового предложения
	// (POST /bids/new)
	CreateBid(ctx echo.Context) error
	// Редактирование параметров предложения
	// (PATCH /bids/{bidId}/edit)
	EditBid(ctx echo.Context, bidId BidId, params EditBidParams) error
	// Отправка отзыва по предложению
	// (PUT /bids/{bidId}/feedback)
	SubmitBidFeedback(ctx echo.Context, bidId BidId, params SubmitBidFeedbackParams) error
	// Откат версии предложения
	// (PUT /bids/{bidId}/rollback/{version})
	RollbackBid(ctx echo.Context, bidId BidId, version int32, params RollbackBidParams) error
	// Получение текущего статуса предложения
	// (GET /bids/{bidId}/status)
	GetBidStatus(ctx echo.Context, bidId BidId, params GetBidStatusParams) error
	// Изменение статуса предложения
	// (PUT /bids/{bidId}/status)
	UpdateBidStatus(ctx echo.Context, bidId BidId, params UpdateBidStatusParams) error
	// Отправка решения по предложению
	// (PUT /bids/{bidId}/submit_decision)
	SubmitBidDecision(ctx echo.Context, bidId BidId, params SubmitBidDecisionParams) error
	// Получение списка предложений для тендера
	// (GET /bids/{tenderId}/list)
	GetBidsForTender(ctx echo.Context, tenderId TenderId, params GetBidsForTenderParams) error
	// Просмотр отзывов на прошлые предложения
	// (GET /bids/{tenderId}/reviews)
	GetBidReviews(ctx echo.Context, tenderId TenderId, params GetBidReviewsParams) error
	// Проверка доступности сервера
	// (GET /ping)
	CheckServer(ctx echo.Context) error
	// Получение списка тендеров
	// (GET /tenders)
	GetTenders(ctx echo.Context, params GetTendersParams) error
	// Получить тендеры пользователя
	// (GET /tenders/my)
	GetUserTenders(ctx echo.Context, params GetUserTendersParams) error
	// Создание нового тендера
	// (POST /tenders/new)
	CreateTender(ctx echo.Context) error
	// Редактирование тендера
	// (PATCH /tenders/{tenderId}/edit)
	EditTender(ctx echo.Context, tenderId TenderId, params EditTenderParams) error
	// Откат версии тендера
	// (PUT /tenders/{tenderId}/rollback/{version})
	RollbackTender(ctx echo.Context, tenderId TenderId, version int32, params RollbackTenderParams) error
	// Получение текущего статуса тендера
	// (GET /tenders/{tenderId}/status)
	GetTenderStatus(ctx echo.Context, tenderId TenderId, params GetTenderStatusParams) error
	// Изменение статуса тендера
	// (PUT /tenders/{tenderId}/status)
	UpdateTenderStatus(ctx echo.Context, tenderId TenderId, params UpdateTenderStatusParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetUserBids converts echo context to params.
func (w *ServerInterfaceWrapper) GetUserBids(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUserBidsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "username" -------------

	err = runtime.BindQueryParameter("form", true, false, "username", ctx.QueryParams(), &params.Username)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter username: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetUserBids(ctx, params)
	return err
}

// CreateBid converts echo context to params.
func (w *ServerInterfaceWrapper) CreateBid(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateBid(ctx)
	return err
}

// EditBid converts echo context to params.
func (w *ServerInterfaceWrapper) EditBid(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "bidId" -------------
	var bidId BidId

	err = runtime.BindStyledParameterWithOptions("simple", "bidId", ctx.Param("bidId"), &bidId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter bidId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params EditBidParams
	// ------------- Required query parameter "username" -------------

	err = runtime.BindQueryParameter("form", true, true, "username", ctx.QueryParams(), &params.Username)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter username: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.EditBid(ctx, bidId, params)
	return err
}

// SubmitBidFeedback converts echo context to params.
func (w *ServerInterfaceWrapper) SubmitBidFeedback(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "bidId" -------------
	var bidId BidId

	err = runtime.BindStyledParameterWithOptions("simple", "bidId", ctx.Param("bidId"), &bidId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter bidId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SubmitBidFeedbackParams
	// ------------- Required query parameter "bidFeedback" -------------

	err = runtime.BindQueryParameter("form", true, true, "bidFeedback", ctx.QueryParams(), &params.BidFeedback)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter bidFeedback: %s", err))
	}

	// ------------- Required query parameter "username" -------------

	err = runtime.BindQueryParameter("form", true, true, "username", ctx.QueryParams(), &params.Username)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter username: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SubmitBidFeedback(ctx, bidId, params)
	return err
}

// RollbackBid converts echo context to params.
func (w *ServerInterfaceWrapper) RollbackBid(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "bidId" -------------
	var bidId BidId

	err = runtime.BindStyledParameterWithOptions("simple", "bidId", ctx.Param("bidId"), &bidId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter bidId: %s", err))
	}

	// ------------- Path parameter "version" -------------
	var version int32

	err = runtime.BindStyledParameterWithOptions("simple", "version", ctx.Param("version"), &version, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter version: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params RollbackBidParams
	// ------------- Required query parameter "username" -------------

	err = runtime.BindQueryParameter("form", true, true, "username", ctx.QueryParams(), &params.Username)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter username: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RollbackBid(ctx, bidId, version, params)
	return err
}

// GetBidStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetBidStatus(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "bidId" -------------
	var bidId BidId

	err = runtime.BindStyledParameterWithOptions("simple", "bidId", ctx.Param("bidId"), &bidId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter bidId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBidStatusParams
	// ------------- Required query parameter "username" -------------

	err = runtime.BindQueryParameter("form", true, true, "username", ctx.QueryParams(), &params.Username)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter username: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBidStatus(ctx, bidId, params)
	return err
}

// UpdateBidStatus converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateBidStatus(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "bidId" -------------
	var bidId BidId

	err = runtime.BindStyledParameterWithOptions("simple", "bidId", ctx.Param("bidId"), &bidId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter bidId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateBidStatusParams
	// ------------- Required query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, true, "status", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter status: %s", err))
	}

	// ------------- Required query parameter "username" -------------

	err = runtime.BindQueryParameter("form", true, true, "username", ctx.QueryParams(), &params.Username)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter username: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateBidStatus(ctx, bidId, params)
	return err
}

// SubmitBidDecision converts echo context to params.
func (w *ServerInterfaceWrapper) SubmitBidDecision(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "bidId" -------------
	var bidId BidId

	err = runtime.BindStyledParameterWithOptions("simple", "bidId", ctx.Param("bidId"), &bidId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter bidId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SubmitBidDecisionParams
	// ------------- Required query parameter "decision" -------------

	err = runtime.BindQueryParameter("form", true, true, "decision", ctx.QueryParams(), &params.Decision)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter decision: %s", err))
	}

	// ------------- Required query parameter "username" -------------

	err = runtime.BindQueryParameter("form", true, true, "username", ctx.QueryParams(), &params.Username)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter username: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SubmitBidDecision(ctx, bidId, params)
	return err
}

// GetBidsForTender converts echo context to params.
func (w *ServerInterfaceWrapper) GetBidsForTender(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "tenderId" -------------
	var tenderId TenderId

	err = runtime.BindStyledParameterWithOptions("simple", "tenderId", ctx.Param("tenderId"), &tenderId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tenderId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBidsForTenderParams
	// ------------- Required query parameter "username" -------------

	err = runtime.BindQueryParameter("form", true, true, "username", ctx.QueryParams(), &params.Username)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter username: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBidsForTender(ctx, tenderId, params)
	return err
}

// GetBidReviews converts echo context to params.
func (w *ServerInterfaceWrapper) GetBidReviews(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "tenderId" -------------
	var tenderId TenderId

	err = runtime.BindStyledParameterWithOptions("simple", "tenderId", ctx.Param("tenderId"), &tenderId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tenderId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBidReviewsParams
	// ------------- Required query parameter "authorUsername" -------------

	err = runtime.BindQueryParameter("form", true, true, "authorUsername", ctx.QueryParams(), &params.AuthorUsername)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter authorUsername: %s", err))
	}

	// ------------- Required query parameter "requesterUsername" -------------

	err = runtime.BindQueryParameter("form", true, true, "requesterUsername", ctx.QueryParams(), &params.RequesterUsername)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter requesterUsername: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBidReviews(ctx, tenderId, params)
	return err
}

// CheckServer converts echo context to params.
func (w *ServerInterfaceWrapper) CheckServer(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CheckServer(ctx)
	return err
}

// GetTenders converts echo context to params.
func (w *ServerInterfaceWrapper) GetTenders(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTendersParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "service_type" -------------

	err = runtime.BindQueryParameter("form", true, false, "service_type", ctx.QueryParams(), &params.ServiceType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter service_type: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTenders(ctx, params)
	return err
}

// GetUserTenders converts echo context to params.
func (w *ServerInterfaceWrapper) GetUserTenders(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUserTendersParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "username" -------------

	err = runtime.BindQueryParameter("form", true, false, "username", ctx.QueryParams(), &params.Username)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter username: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetUserTenders(ctx, params)
	return err
}

// CreateTender converts echo context to params.
func (w *ServerInterfaceWrapper) CreateTender(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateTender(ctx)
	return err
}

// EditTender converts echo context to params.
func (w *ServerInterfaceWrapper) EditTender(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "tenderId" -------------
	var tenderId TenderId

	err = runtime.BindStyledParameterWithOptions("simple", "tenderId", ctx.Param("tenderId"), &tenderId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tenderId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params EditTenderParams
	// ------------- Required query parameter "username" -------------

	err = runtime.BindQueryParameter("form", true, true, "username", ctx.QueryParams(), &params.Username)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter username: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.EditTender(ctx, tenderId, params)
	return err
}

// RollbackTender converts echo context to params.
func (w *ServerInterfaceWrapper) RollbackTender(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "tenderId" -------------
	var tenderId TenderId

	err = runtime.BindStyledParameterWithOptions("simple", "tenderId", ctx.Param("tenderId"), &tenderId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tenderId: %s", err))
	}

	// ------------- Path parameter "version" -------------
	var version int32

	err = runtime.BindStyledParameterWithOptions("simple", "version", ctx.Param("version"), &version, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter version: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params RollbackTenderParams
	// ------------- Required query parameter "username" -------------

	err = runtime.BindQueryParameter("form", true, true, "username", ctx.QueryParams(), &params.Username)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter username: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RollbackTender(ctx, tenderId, version, params)
	return err
}

// GetTenderStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetTenderStatus(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "tenderId" -------------
	var tenderId TenderId

	err = runtime.BindStyledParameterWithOptions("simple", "tenderId", ctx.Param("tenderId"), &tenderId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tenderId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTenderStatusParams
	// ------------- Optional query parameter "username" -------------

	err = runtime.BindQueryParameter("form", true, false, "username", ctx.QueryParams(), &params.Username)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter username: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTenderStatus(ctx, tenderId, params)
	return err
}

// UpdateTenderStatus converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateTenderStatus(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "tenderId" -------------
	var tenderId TenderId

	err = runtime.BindStyledParameterWithOptions("simple", "tenderId", ctx.Param("tenderId"), &tenderId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tenderId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateTenderStatusParams
	// ------------- Required query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, true, "status", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter status: %s", err))
	}

	// ------------- Required query parameter "username" -------------

	err = runtime.BindQueryParameter("form", true, true, "username", ctx.QueryParams(), &params.Username)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter username: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateTenderStatus(ctx, tenderId, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/bids/my", wrapper.GetUserBids)
	router.POST(baseURL+"/bids/new", wrapper.CreateBid)
	router.PATCH(baseURL+"/bids/:bidId/edit", wrapper.EditBid)
	router.PUT(baseURL+"/bids/:bidId/feedback", wrapper.SubmitBidFeedback)
	router.PUT(baseURL+"/bids/:bidId/rollback/:version", wrapper.RollbackBid)
	router.GET(baseURL+"/bids/:bidId/status", wrapper.GetBidStatus)
	router.PUT(baseURL+"/bids/:bidId/status", wrapper.UpdateBidStatus)
	router.PUT(baseURL+"/bids/:bidId/submit_decision", wrapper.SubmitBidDecision)
	router.GET(baseURL+"/bids/:tenderId/list", wrapper.GetBidsForTender)
	router.GET(baseURL+"/bids/:tenderId/reviews", wrapper.GetBidReviews)
	router.GET(baseURL+"/ping", wrapper.CheckServer)
	router.GET(baseURL+"/tenders", wrapper.GetTenders)
	router.GET(baseURL+"/tenders/my", wrapper.GetUserTenders)
	router.POST(baseURL+"/tenders/new", wrapper.CreateTender)
	router.PATCH(baseURL+"/tenders/:tenderId/edit", wrapper.EditTender)
	router.PUT(baseURL+"/tenders/:tenderId/rollback/:version", wrapper.RollbackTender)
	router.GET(baseURL+"/tenders/:tenderId/status", wrapper.GetTenderStatus)
	router.PUT(baseURL+"/tenders/:tenderId/status", wrapper.UpdateTenderStatus)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"alw1ZsxaUW/ebf4zAAD//77o5uqyhQAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
